Name:
	Adeeb Sheikh
Class:
	CSC 173
Assignment:	
	To create a calculator that scans, tokenizes, parses, and evaluates a file containing arithmetic expressions.
	Also note, this file uses the NEW specifications for incrementation. However, the sign can be encapsulated in parentheses or not -- your choice.

How to Run:
	1.	On the command line, 'cd' into the directory where the .c-files are being stored.
	2.	Run the makefile by entering 'make'.
	3.	After the programs have been compiled, enter './calculator input.txt', but replace 'input.txt' with the name of your desired input file.

Description of Files:
	README.txt
		This file.
	WRITEUP.pdf
		The writeup for this project.
	main.c
		The file with the main method. It calls the 'parse' method from the 'parser.c' file. It's taken directly from the legacy code.
	reader.c
		The legacy code contained here reads the file inputted in the main method and then puts the entire file into a linkedlist of lines, for future use.
	reader.h
		The header file for 'reader.c'. This contains the structs and the method prototypes for 'reader.c'.
	scanner.c
		This file contains the tokenizer for the entire program. It tokenizes from the linkedlist of lines passed from 'reader.c' and passes the tokens one at a time whenever 'scan' is called. It's based on legacy code, but modified significantly for the purposes of this project.
	scanner.h
		The header file for scanner. This contains the enumeration of token types, the struct token_t, and the prototypes for methods in 'scanner.c'.
	parser.c
		The file that parses and evaluates the file from scanned in tokens. It does so by first constructing a parse tree, by scanning in the tokens one at a time and following pre-determined productions in a recursive descent way from a previously created context free grammar. The recursive descent is implemented by creating a function for every syntactic group, then running the terminal type of the next token through a switch-case that calls other syntactic group functions based on the productions. After tree construction, the parse tree is recursively evaluated from the bottom up. The evaluation occurs recursively, deciding what to do based on a switch-case for the label of each node in the tree. (The label describes whether a node contains a terminal or a syntactic group, and which type of either it is -- by assigning ints to every terminal and syntactic group using an enum in the header.) In the evaluation function, if the label is for a syntactic group, it makes another recursive call and if its for a terminal, it returns a solid value. In addition, there is a pretty printer method used for debugging and error messages based on code from this stack-overflow thread: http://stackoverflow.com/questions/1649027/how-do-i-print-out-a-tree-structure. After this, there are several self-implemented math functions. Finally, this file has the capability for extensive error-handling, based on the legacy code. When the tree is being constructed and an error is encountered, it returns a syntax error with the location in-file of the error. When the tree is being evaluated, it returns and evaluation error and prints the troublesome node and all its children.
	parser.h
		The header file for 'parser.c'. Contains lots of enumerations, method prototypes, and structs. The most interesting thing here is the definition of node_t, which is used extensively in 'parser.c'.
	char_classes.c
		Legacy code that classifies every character into a different class using an array.
	char_classes.h
		The associated character header file for 'char_classes.c'.
	sample_input.txt
		The sample input created for this project.
	sample_output.txt
		The output generated by the program when the the 'sample_input.txt' is taken as input.

Extra Credit:
	This project has implemented version control using git. In addition, this project can implement two extra operators not specified inside the 'MISSION.txt': the factorial method and the exponent method. The exponent method can handle both floating-point bases and floating-point indices. This was done based on some code by from this stack-overflow thread: //http://stackoverflow.com/questions/3518973/floating-point-exponentiation-without-power-function. The factorial can also take floating-point inputs greater than -1.0. For the integers, this is simple and straightforward -- a 'for' loop is implemented as you would expect. For the floating-point inputs, the calculation is completed using an approximation of the Euler-Gamma function (which is designed to give the factorial function some continuity), called Stirling's Approximation. Of course, Stirling's Approximation is just that -- an approximation, so take the results with a grain of salt. This is especially apparent at lower inputs, but once the factorial inputs exceed eight, the precision of Stirling's Approximation exceeds eight digits. In addition, there is a capability for error handling -- this program passes error messages with the location of errors, whenever a syntax error is read while the file is being parsed, and it passes evaluation error messages and prints troublesome nodes, whenever there is an error as the parse tree is being evaluated.